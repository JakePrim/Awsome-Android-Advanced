<html>

<body>

    <!-- 不同标签下的作用域 -->
    <script>
        var a = 1;
    </script>
    <!-- script 是顺序执行的 在上一个标签中声明了变量a 在下一个标签中也能得到a -->
    <script>
        console.log(a);//这时候是找不到  
    </script>
    <!-- <script>
          var a = 1;
          </script> -->


    <script>
        //什么是变量
        //操作数据、保存数据的容器

        // var score = 4;
        //基本类型: 4 'str' true/fasle 基本类型的值是不能够修改的 可以被覆盖
        //基本类型保存在 栈内存中
        //引用类型:[] {} 保存在堆内存中,引用类型在堆内存中的地址 保存在栈内存中,通过地址来访问引用的数据
        // var person = [1,'s',2,true];
        // console.log(person[0]);
        // console.log(person[1]);
        // var preson = {
        //     text:'小明',
        //     sex:'男',
        //     action:function(){
        //         console.log('action');
        //     }
        // };
        // //添加属性
        // preson.text ='小明';
        // preson.sex ='男';
        // //添加方法
        // preson.action = function(){

        // }
        // console.log(preson);
        // delete preson.sex;//删除属性
        // console.log(preson);
        // //函数是引用类型 可以为其添加属性和方法 
        // function fn(){

        // }
        // fn.name = 'xm';
        // console.log(fn.name);
        // document.write(fn.name);

        // var xm = {
        //     name:'小明',
        //     sex:'女'
        // }

        // var xh = {
        //     name:'小明',
        //     sex:'女'
        // }
        //不相等 引用类型 只有指向同一个引用才相等 xm xh 开辟了两个不同的空间 
        // console.log(xm === xh);

        // function equleObj(a,b){
        //     for(var x in a){
        //         if(a[x] !== b[x]) return false;
        //     }
        //     return true;
        // }

        // function copyObj(obj){
        //     var newObj = {};
        //     for(var oj in obj){
        //         newObj[ij] = obj[oj];
        //     }
        //     return newObj;
        // }
        //==比较的是值，===比较的是值和类型
        /**
         * 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，
         * 因此两个变量最终都指向同一个对象，当给变量赋新值时，此变量就不再指向原来的对象了；
数组是引用类型的 , 如题中b=a相当于a与b指向同一个地址 , 但是a=[4,44]之后改变了a的地址 ,
所以b不会受到影响 为[4] . 后面又把a=b指向了同一个地址 ,此时为b添加元素 , 
因为a、b的地址都没有改变 ,a也会随之改变 ,所以a为[4,44] . 
         */

        //js 的解析机制
        //  var name = 'xm';
        //  var age = 18;
        //  function fn(argument) {
        //     console.log(name);
        //      var name = 'xh';
        //      var age = 20;
        //  }
        //  fn();
        //js的解析过程
        //预解析
        //  window 
        //    name = undefined
        //    age = undefined
        //    fn(){....}
        // fn
        //   name = undefined
        //   age = undefined 
        //   argument = undefined
        // //然后逐行解析代码
        // window 
        //    name = 'xm'
        //    age = 18
        //    fn(){....} //跳过
        // 执行fn 这时候局部变量name并没有被解析执行 所以得到的就是undefined
        // fn
        //   name = undefined
        //   age = undefined 
        //   argument = undefined

        //不要在if 或者 for中定义函数
        //1. 以var 声明的变量 会预解析 
        //2. 以let 声明的变量 不会进行预解析 
        //3. 函数的声明会预解析 
        //4. 函数表达式不进行预解析

        //fn函数在预解析时，已经提前进行了该函数的声明
        // document.write(fn1);//输出 function fn1(params){}
        // function fn1(params) {

        // }

        //再看如下的解析
        // document.write(fn2);
        // //注意这是变量赋值不是函数声明 预解析后的fn2 = undefined
        // var fn2 = function(){};

        //1.JS 作用域问题
        //1⃣️
        // console.log(a);
        // var a = 1;
        //2⃣️
        // console.log(a);//报错 not defined
        // a = 1;//没有var 就不能正常的预解析

        //2.
        console.log(a);//function a(){console.log(4);}
        var a = 1;
        console.log(a);//1
        function a() {
            console.log(2);
        }
        console.log(a);//1
        var a = 3;
        console.log(a);//3
        function a() {
            console.log(4);
        }
        console.log(a);//3
        a();//报错
                    /**
         * 执行过程,Js在预解析时 提前进行了函数的声明,对于同名的函数
         * 最后一个会覆盖前一个
         * 所以第一个log,输出最后一个函数声明
         * 预解析的结果 函数名和变量名冲突则变量名被移除
         * a = undefined
         * a(){..} a= undefined 移除
         * a = undefined
         * a(){..} a = undefined 移除
         *
         * 解析过程
         * 输出log
         * 声明了变量a 函数a()移除
         * 1
         * 1
         * 3
         * 3
         *
         *
         */


    </script>
</body>

</html>